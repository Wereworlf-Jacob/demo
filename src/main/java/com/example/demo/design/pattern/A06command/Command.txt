命令模式:  将请求封装成对象，这可以让你使用不同的请求、队列，或者日志请求来参数化其他对象。命令模式也可以支持撤销操作
    把方法调用（method invocation）封装起来
    实现类似：记录日志，或者重复使用这些封装来实现撤销（undo）
基本命令模式：
    由控制器（遥控器），命令（开关），行为对象（电灯，风扇等）
    暴露给用户的就是一个控制器，用户只需要操作控制器的开关，就能控制行为对象做出各种动作
    比如摁遥控器打开风扇，调用打开风扇的命令，就会操作风扇打开操作
2.0命令模式：
    行为对象，通过一个属性（比如position来控制它的类型）
    比如卧室一个电灯，厨房一个电灯，那么我通过lightOn命令怎么控制打开哪个电灯呢？
    我们就需要创建一个position=卧室，一个position=厨房的电灯，然后把电灯给command命令
    那么就区分出来的不同位置的电灯
    我们的控制器上有有限个数的插槽，初始化的遥控器要每个插槽一个NoCommand对象，类似于空对象，
    为了方便我们不需要给每个插槽进行判空，简化代码，这也是一个设计方式
3.0命令模式：
    我们基于打开和关闭操作，还增加了撤销操作，其中撤销分为开/关操作撤销和有状态的撤销
    比如，简单的开/关 yes/no 结构，那么yes的undo就是no，no的undo就是yes
    而有状态的撤销，status 1/2/3，我们就需要记录在操作之前的这一个状态是怎样的。
    而这个状态，是属于行为对象的，记录这个状态是属于命令的。执行命令之前，获取对象的状态值，
    然后在撤销的时候，根据这个状态值，再设置对象的行为。
    除撤销以外，我们还增加了宏命令，比如，我们要开party，那么我打开party模式，就可以执行一系列的命令，
    比如打开灯，打开音响，打开电视。实现一键开启模式

总的来讲：
命令可以将运算块刀包成一个对象（一个接收者和一组动作），然后将它传来传去。命令对象被创建之后，运算以然可以被调用。
他可以在不同的线程中被调用。这样就可以衍生出来一些应用，例如：日程安排、线程池、工作队列等
比如，在某一端添加命令，然后在另一端则是线程，线程从队列中取出一个命令，调用它的execute方法，等待这个调用完成，
命令将对象丢弃，再取出下一个命令，因为线程不知道你这个运算块对象是在干什么，是解耦的所以，可能此时在进行财务运算，
而下一个就读取网络数据。