模板方法模式：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。
            模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
    封装算法

模拟泡咖啡和泡茶：
    在传统的代码下，我们发现了重复的代码，泡水和装进杯子里。既然有相似，我们应该提取公共部分为基类
使用模板方法模式：
    我们发现，共同的流程为 1、烧水 2、冲泡/浸泡 3、装进杯子 4、添加柠檬或者牛奶+糖
    其中1，3为固定行为，2，4也定义为 冲泡 和 添加调味品。
    这样我们在一个模板中，就可以指定流程1，2，3，4.同时2，4为抽象方法，由子类来实现
    同时，我们还可以定义钩子方法，来使子类能通过自己的行为影响到某一些模板流程的执行
    使用钩子方法的好处在于：子类可选，可以重写也可以不重写，这样能最大程度地减少子类的代码量

与策略模式的区别：
    策略模式：
        同样是封装算法，策略模式使用的是组合的方式，封装了一堆算法，客户可以根据自己的需求选择合适的算法
    模板方法模式：
        同样是封装算法，模板使用的是集成的方式，封装了公共的基类算法在超类，子类可以扩展自己的算法。
        模板定义的是一个算法大纲，在这个前提下，子类可以实现超类的抽象方法实现自己的算法，也可以通过钩子方法
        来定义模板的某个流程是否执行
在java中存在大量的模板方法模式：
    比如，排序：我们可以实现Comparable接口，重写compareTo方法，然后调用Arrays.sort()方法。
        在sort()方法就是一个模板方法，由子类comparable的compareTo来确定排序规则是什么，然后由sort()
        来根据你指定的排序规则进行排序，而不需要你自己去冒泡排序了，归并排序了，等一些没必要的操作
